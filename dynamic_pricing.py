# -*- coding: utf-8 -*-
"""dynamic pricing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VU9PQ-rPdtbMHyvDdRd3fHlqUpT1-eeq

O Preço dinâmico é uma estratégia na qual o preço dos produtos ou serviços continuam a se ajustar em resposta á oferta e demanda em tempo real. Ele resolveu os problemas de estratégias históricas de preços que eram rígidos na sua estrutura e não respondiam facilmente às mudanças na procura e oferta.

Creditos ao dataset: https://statso.io/dynamic-pricing-case-study/
"""

import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

data = pd.read_csv("/content/dynamic_pricing.csv")

"""# EDA"""

print(data.head())

data.head()

print(data.describe())

"""## ScatterPlot: relação entre duração esperada da viagem e o custo histórico"""

fig = px.scatter(data, x='Expected_Ride_Duration',
                 y='Historical_Cost_of_Ride',
                 title='relação entre duração esperada da viagem e o custo histórico',
                 trendline='ols')
fig.show()

"""### existe uma distribuição linear que mostra que uma variável é diretamente proporcional à outra, ou seja, (um aumento na duração esperada da viagem levará a um aumento correspondente no custo da viagem), o que faz sentido porque quanto mais longa a viagem, mais dinheiro vai custar.

## boxplot: custo de viaegem em relação ao tipo de veículo
"""

fig = px.box(data, x='Vehicle_Type',
             y='Historical_Cost_of_Ride',
             title='custo de viaegem em relação ao tipo de veículo')
fig.show()

"""o custo de um veículo premium (cerca de 400) é superior ao custo do veículo econômico (cerca de 330), isto também é esperado considerando fatores como conforto e número de assentos o carro. (Alguns aplicativos de carona limitam o número máximo de passageiros que podem acomodar um carro com base no tipo de veículo).

##boxplot: custo da viagem em relação ao momento da reserva
"""

fig = px.box(data, x='Time_of_Booking',
             y='Historical_Cost_of_Ride',
             title='custo da viagem em relação ao momento da reserva')
fig.show()

"""### o custo histórico de uma viagem é alto pela manhã (cerca de 380) e mais alto à tarde (cerca de 390), mas diminui ao anoitecar (cerca de 360) e é mais baixo ainda à noite (cerca de 330). Isso é esperado considerando fatores como a quantidade de tráfego de veículos durante o dia: tráfego intenso de veículos nas horas da manhã e da tarde, mas menos tráfego ao anoitecer.

## Correlação entre todas as variáveis
"""

fig = px.imshow(data.corr(), text_auto=True,
                 title='Correlação entre todas as variáveis')
fig.show()

"""### podemos deduzir uma forte correlação entre a duração esperada da viagem e o custo histórico da viagem

# implementação do código estratégia de preços dinâmicos:
"""

import numpy as np

#calculando multiplicador de demanda com base no percentil para alta e baixa demanda
high_demand_percentile = 75
low_demand_percentile = 25

data['demand_multiplier'] = np.where(data['Number_of_Riders'] > np.percentile(data['Number_of_Riders'], high_demand_percentile),
                                     data['Number_of_Riders'] / np.percentile(data['Number_of_Riders'], high_demand_percentile),
                                     data['Number_of_Riders'] / np.percentile(data['Number_of_Riders'], low_demand_percentile))

#calculando multiplicador de oferta com base no percentil para oferta alta e baixa
high_supply_percentile = 75
low_supply_percentile = 25

data['supply_multiplier'] = np.where(data['Number_of_Drivers'] > np.percentile(data['Number_of_Drivers'], low_supply_percentile),
                                     np.percentile(data['Number_of_Drivers'], high_supply_percentile) / data['Number_of_Drivers'],
                                     np.percentile(data['Number_of_Drivers'], low_supply_percentile) / data['Number_of_Drivers'])

#fatores de ajuste de preços para alta e baixa demanda/oferta
demand_threshold_high = 1.2 #limite de demanda mais alto
demand_threshold_low = 0.8 #limite de demanda mais baixo

supply_threshold_high = 0.8 #limite de oferta mais alto
supply_threshold_low = 1.2 #limite de oferta mais baixo

#calculando o custo ajustado da viagem para preços dinâmicos
data['adjusted_ride_cost'] = data['Historical_Cost_of_Ride'] * (
    np.maximum(data['demand_multiplier'], demand_threshold_low) *
    np.maximum(data['supply_multiplier'], supply_threshold_high)
)

#Calculando a porcentagem de lucro para cada viagem usando estratégia de preços dinâmicos

data['profit_percentage'] = ((data['adjusted_ride_cost'] - data['Historical_Cost_of_Ride']) / data['Historical_Cost_of_Ride']) * 100

#Identificando viagens lucrativas quando a porcentagem de lucro for positiva
profitable_rides = data[data['profit_percentage'] > 0]

#Identificando  viagens incorrendo em perdas quando a porcentagem de lucro é negativa
loss_rides = data[data['profit_percentage'] < 0]

import plotly.graph_objects as go

#calcular a contagem de viagens lucrativas e perdidas
profitable_count = len(profitable_rides)
loss_count = len(loss_rides)

#criação de um piechart para mostrar a distribuição de viagens lucrativas e com perdas usando a estratégia de precificação dinâmica
labels = ['Profitable Rides', 'Loss Rides']
values = [profitable_count, loss_count]

fig = go.Figure(data=[go.Pie(labels=labels, values=values, hole=0.4)])
fig.update_layout(title='Lucratividade das viagens (Preço dinâmico vs dados históricos)')
fig.show()

#Criação de um gráfico de dispersão para visualizar a relação entre a duração esperada da viagem e o custo da viagem com base na estratégia de preços dinâmicos
fig = px.scatter(data,
                 x='Expected_Ride_Duration',
                 y='adjusted_ride_cost',
                 title='Duração esperada da viagem vs custo da viagem',
                 trendline='ols')
fig.show()

"""# Treinando Modelo"""

from sklearn.preprocessing import StandardScaler

def data_preprocessing_pipeline(data):
  #Separando variaveis numéricas e categóricas
  numeric_features = data.select_dtypes(include=['float','int']).columns
  categorical_features = data.select_dtypes(include=['object']).columns

  #tratando valores faltantes nas variáveis numéricas
  data[numeric_features] = data[numeric_features].fillna(data[numeric_features].mean())

  #Tratando outliers
  for feature in numeric_features:
    Q1 = data[feature].quantile(0.25)
    q3 = data[feature].quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = q1 - (1.5 * IQR)
    upper_bound = q3 + (1.5 * IQR)
    data[feature] = np.where((data[feature] < lower_bound) | (data[feature] > upper_bound),
                             data[feature].mean(), data[feature])

    #Tratando valores faltantes em variáveis categóricas
    data[categorical_features] = data[categorical_features].fillna(data[categorical_features].mode().iloc[0])

    return data

#Convertendo a variável "Vehicle_type" em numérico (0,1)
data["Vehicle_Type"] = data["Vehicle_Type"].map({"Premium": 1, "Economy": 0})

#Convertendo a variável "Time_of_Booking" em numérico (0,1,2,3)
data["Time_of_Booking"] = data["Time_of_Booking"].map({"Afternoon": 0, "Evening": 1, "Morning": 2, "Night": 3})

#Dividindo entre train test
from sklearn.model_selection import train_test_split
x = np.array(data[["Number_of_Riders", "Number_of_Drivers", "Vehicle_Type", "Time_of_Booking", "Expected_Ride_Duration"]])
y = np.array(data[["adjusted_ride_cost"]])

x_train, x_test, y_train, y_test = train_test_split(x,
                                                    y,
                                                    test_size=0.2,
                                                    random_state=42)

#Reshape y para 1D array
y_train = y_train.ravel()
y_test = y_test.ravel()

#Treinando o RANDOM FOREST
from sklearn.ensemble import RandomForestRegressor
model = RandomForestRegressor()
model.fit(x_train, y_train)

"""## Avaliando o Modelo"""

#predição do modelo
y_pred = model.predict(x_test)

#verificando a acurácia
from sklearn.metrics import r2_score

r2_score(y_test, y_pred)*100

"""## Validando com novos valores"""

#Testando o modelo usando valores de entrada
def get_vehicle_type_numeric(vehicle_type):
  vehicle_type_mapping = {
      "Premium": 1,
      "Economy": 0
  }
  vehicle_type_numeric = vehicle_type_mapping.get(vehicle_type)
  return vehicle_type_numeric

def get_time_of_booking_numeric(time_of_booking):
  time_of_booking_mapping = {
      "Afternoon": 0,
      "Evening": 1,
      "Morning": 2,
      "Night": 3
  }
  time_of_booking_numeric = time_of_booking_mapping.get(time_of_booking)
  return time_of_booking_numeric

#Fazendo previsões usando valores de entrada do usuário
def predict_price(number_of_riders, number_of_drivers, vehicle_type, time_of_booking, Expected_Ride_Duration):
  vehicle_type_numeric = get_vehicle_type_numeric(vehicle_type)
  if vehicle_type_numeric is None:
    raise ValueError("Invalid vehicle type")

  time_of_booking_numeric = get_time_of_booking_numeric(time_of_booking)
  if time_of_booking_numeric is None:
    raise ValueError("Invalid time of booking")

  input_data = np.array([[number_of_riders, number_of_drivers, vehicle_type_numeric, time_of_booking_numeric, Expected_Ride_Duration]])
  predicted_price = model.predict(input_data)
  return predicted_price

#Exemplo de entrada
user_number_of_riders = 65
user_number_of_drivers = 30
user_vehicle_type = "Economy"
user_time_of_booking = "Afternoon"
Expected_Ride_Duration = 50
predicted_price = predict_price(user_number_of_riders, user_number_of_drivers, user_vehicle_type, user_time_of_booking, Expected_Ride_Duration)
print("The predicted price for the ride is:", predicted_price)

"""## Visualizando o resultado"""

#Comparação de resultados reais e previstos
import plotly.graph_objects as go

#Predict nos dados de teste
y_pred = model.predict(x_test)

#Scatterplot com valores atuais x valores preditos
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=y_test.flatten(),
    y=y_pred,
    mode='markers',
    name='Actual vs Predicted'
))

#Adicionar uma linha representando o cenário ideal
fig.add_trace(go.Scatter(
    x=[min(y_test.flatten()), max(y_test.flatten())],
    y=[min(y_test.flatten()), max(y_test.flatten())],
    mode='lines',
    name='Ideal',
    line=dict(color='red', dash='dash')
))

fig.update_layout(
    title='Valores atuais x preditos',
    xaxis_title='Valores atuais',
    yaxis_title='Valores Preditos',
    showlegend=True
)

fig.show()

